# Radiation-Source-Identification-System
## 主要使用的模块：

+ PyWebIO
+ pytorch

PyWebIO能够让我们使用Python来进行前端的编写，通过Python代码，和css可以控制内部的元素样式。

## 代码目录结构：
+ anomaly.db        # 异常检测数据库
+ anomaly.py        # 异常检测代码
+ app.py            # 程序代码入口
+ classification.py # 分类文件
+ cls.db            # 分类数据库
+ data              # 上传数据的存放地点
+ fig               # 界面的logo图片
+ mini_dataset      # 测试的迷你数据集
+ model.py          # 使用到的深度学习模型
+ new_feature.py    # 新功能文件
+ test              # 测试文件

## Run the code
```
python3 app.py
```

## 函数介绍:

### app.py
该文件中主要有ui函数, 为整个UI界面的启动，包括所有的功能，都写在该函数中。最早实现的功能有：

+ 数据上传
+ 数据可视化
+ 数据分类: 对上传的数据进行分类，点击数据分类模块后，就会对数据分类，分类后，可以清除数据结果，以及数据筛选
+ 异常检测: 对上传的数据进行异常检测，点击数据异常检测模块后，就会调用异常检测函数，同样可以清除数据结果，以及数据筛选

后面补充两个新的功能：

+ 重新训练模型: 重新训练异常检测模型和分类模型
+ 更新训练数据: 将检测的数据，添加到训练数据中，和更新训练模型功能配合

#### start_server

启动UI界面，通过端口localhost:36536可以进行访问

在PyWebIO中，start_server()函数用于启动一个Web服务器，并将带有PyWebIO应用程序的页面服务。debug参数是可选的，用于设置调试模式。

当debug设置为True时，PyWebIO将在运行期间输出详细的调试信息，在开发和调试应用程序时非常有用。此时，运行PyWebIO应用程序时，Web浏览器将现在在调试模式下，同时Python控制台将显示详细的应用程序运行日志。

但是，当准备将应用程序部署到生产环境时，应将debug设置为False或省略该参数。这样可以避免在生产环境中泄露敏感信息，并提高应用程序的安全性。

#### ui
查看pywebio.output.put_row函数，里面有很多put_buttons功能。

每个button都是界面上的一个功能按键，点击对应的按键，就能调用其中的函数。调用onclick后面的函数

#### upload
这段代码定义了一个名为upload()的函数，用于处理用户上传的文件。其中：

1. 首先使用 global 关键字声明文件变量 file，方便后续的操作。
2. 使用 PyWebIO 的 input.file_upload() 函数获取用户上传的文件，并将其保存在 file 变量中。
3. 使用 os.makedirs() 建立一个名为"data"的目录，以存储用户上传的文件。如果该目录已经存在，那么就忽略此步骤。
4. 如果用户没有上传任何文件，那么将会显示一个错误信息 "不能上传空数据!"。
5. 如果用户上传了文件，那么就将该文件存储到 data 目录下，并且使用 check_data() 函数检查已经上传的数据。

#### update_training_data
该代码在new_feature.py 文件中。

这段代码定义了一个名为update_training_data()的函数，用于更新训练数据。其中：

1. 使用 PyWebIO 的 actions() 函数，让用户选择需要执行的功能，即 "数据筛选" 或 "数据上传"。
2. 如果用户选择了 "数据筛选"，那么会再次使用 actions() 函数，让用户选择筛选异常数据还是分类数据。
3. 如果用户选择了 "筛选异常数据"，那么会从数据库中读取标签为1的文件名，并将这些文件移动到一个新创建的类别文件夹中（假设只有一个新类别）。
4. 如果用户选择了 "筛选分类数据"，那么会从数据库中读取已有的类别和相应的文件名，并将这些文件移动到对应的类别文件夹中。
5. 如果用户选择了 "数据上传"，那么会先列出已经存在的类别文件夹，让用户选择将文件上传到哪个文件夹中。然后使用 input.file_upload() 函数让用户上传具体的文件，并将该文件添加到所选的类别文件夹中。

备注：该函数中的文件路径和数据库文件名可能需要根据实际情况进行修改。

#### retrain_model
该代码在new_feature.py 文件中。

这段代码实现了重新训练分类模型或者异常检测模型的功能，并通过交互式对话提示用户选择需要执行的功能，具体步骤如下：

1. 调用actions函数，提示用户选择“重新训练分类模型”或“重新训练异常检测模型”功能。
2. 根据用户的选择，执行相应的训练命令。
3. 将训练过程中的输出信息打印到控制台。

说明：重新训练模型调用的是subporcess模块，即在python中开启另一个进程，调用其他软件。比如按下按钮后，就会通过python运行shell脚本，重新训练模型，注意，这里重新训练的模型名字，要与之前的加载的函数名字一样。

#### visualize
这段代码定义了一个名为visualize()的函数，并将其装饰为使用 PyWebIO 交互的函数。该函数用于展示音频数据的波形图和频谱图。

1. 函数首先会使用numpy的fromfile()函数从指定的文件目录读取音频文件数据，然后将数据按照每8192个数据点为一帧，将数据划分为多帧，并选取第一帧数据用于展示波形图。接下来对数据进行幅值归一化处理，并使用plotly库绘制波形图。绘制完成后，将结果转换成 HTML 代码，并使用 PyWebIO 的put_html()函数将波形图输出到页面，用于展示。

2. 接着，该函数对原始音频数据进行快速傅里叶变换，获取到频域表示的数据，并使用plotly库绘制频谱图。同样，绘制完成后，将结果转换成 HTML 代码，并使用 PyWebIO 的put_html()函数将频谱图也输出到页面，用于展示。

3. 在函数的最后，使用 PyWebIO 的put_collapse()函数将前面绘制出来的波形图和频谱图包裹在一起，形成可折叠展示的结果框，提升页面整体的可读性。同时为了防止和前面的波形图产生冲突，将波形图绘制结果放到名为 scope1 的作用域中，将频谱图的绘制结果放到名为 scope2 的作用域中。scope clear的作用是，每次点击按钮，就会先对该区域进行清除，否则会内容会一直堆积在网页上，影响观看。

#### anomaly_detection
该函数为异常检测按钮，里面有两个功能进行选择：

+ 数据筛选
+ 数据清除
+ 
代码在anomaly.py文件中，主要使用了下面四个函数。

from anomaly import load_anomaly_model, test_anomaly, anomaly_save_and_sort, anomaly_data_select_func

从app.py文件第25行可以看出，本代码先加载了异常检测模型。如果重新训练模型的话，要重新启动整个项目，才会加载新的模型，这里可以自己改进下。

test_anomaly: 函数则会使用加载的异常检测模型，对数据进行异常检测，并将该模型的检测结果返回。返回的参数如下：

+ name：检测的文件名
+ time：检测时间
+ error：异常值，模型检测后会生成的值
+ label：是否为异常数据，这里代码设置的大于0.2为异常，0表示非异常
+ anomaly_save_and_sort: 将检测的结果，存储到SQLite数据库中，并且对检测结果按时间排序，并且将检测结果设置成表格的形式，显示在前端中, 最近的检测结果会显示在表格上面。

anomaly_data_select_func : 添加了数据筛选功能，但点击该按钮，就会弹出数据筛选，输入数据的特征后，就会对数据库中的结果进行查询筛选，最后将符合条件的结果，以表格的形式显示出来。

#### classification
该函数为模型分类按钮，里面有两个功能进行选择：

+ 数据筛选
+ 数据分类
该函数主要调用了四个函数：

from classification import load_cls_model, test_cls, cls_save_and_sort, cls_data_select_func
